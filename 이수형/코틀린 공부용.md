# 코틀린 공부용

---

## 210723 기본 입출력부터

### switch 대신 when 사용 else 있어야함 print에 when 넣어서 출력가능

```kotlin
when{
    num1 < num2 -> "<"
    num1 == num2 -> "=="
else-> ">"
}
```

---

### Scanner main에 붙이면 바로 nextInt() 같은것 사용가능

```kotlin
fun main(args: Array<String>) = with(Scanner(System.in)){}
```

---

### 프린트문안에 nextInt 여러개 받아와서 출력 바로가능

```kotlin
println(nextInt() + nextInt())
```

---

## 210724 조건, 반복, 배열 등

---

### 배열 이런식으로 선언 초기화 (다른방법찾아볼것)

바로 { } 안의 람다식을 이용해 초기화가능

```kotlin
var array = IntArray(N);

val array: Array<Int> = Array(10, {i -> i+1}) 
```

---

### for문 안에 원래하던 범위지정대신 in쓰고 .. 이나 until로 범위지정

```kotlin
for (i in 1..N) for(i in 1 until N)
```

---

### if문을 변수에 바로 넣어줄수있음 else문 꼭 필요

### 또한 { 변수+= if문 } 형태로 더해줄 값 if문 지정가능

```kotlin
cnt += if (temparr[k] > (sum / num)) 1.0 else 0.0
```

---

### 변수 출력형식 지정 print문안에서 자바처럼 %2f 등으로 지정하고

### . format(변수) 로 지정

```kotlin
println("%.3f".format((cnt))
```

---

### 코틀린도 자바랑 split 하는것 비슷

```kotlin
var temp = a.split(" ")
```

---

### 배열출력은 for each 이고 그안에서 it로 인자에 접근하고 { } 사이에 식 가능

```kotlin

arr.foreach{ print(it) } // 프린터할때는 괄호안에 it로 받아온 인자 print
```

---

## 210727 Collection

---

Collection은 Mutable을 붙인 List, Set, Map 과 그냥 List, Set, Map이 있고 Mutabel은 값 수정이 가능하나 그냥 선언하게 되면 초기화한 값그대로 읽을수만 있음

```kotlin
val list = listOf(값) // = mutableListOf(값)
val set = setOf(값) // = MutableSetOf(값)
val map = mapOf(키,값) // = MutableMapOf(키,값)
```

---

Sort는 자바처럼 Arrays.sort()도 사용가능하고 만든 리스트에 .sort()를 붙이면 정렬되고

정렬된 값을 다른 리스트에 저장할때는 = .sorted()로 반환해준다

```kotlin
list.sort()
list2 = list.soreted()
```

## 210728 Stack, Queue

코틀린에는 stack과 queue가 구현되어있는 라이브러리가 없으며 대신 같은 JVM을 쓰는

자바의  java.util 라이브러리를 사용하거나 ArrayList, MutableList를  큐나 스택처럼 사용하는 

방법이있다

```kotlin
//Stack으로 사용되는 2가지
var mutableList = mutableListOf<Int>()
var arrayList = arrayListOf<Int>()
//push==add , pop==removeAt , top (구현) , isEmpty, size

//자바 라이브러리는 같음
```

---

큐의 경우 java.util의 라이브러리를 사용할때는 주로 LinkedList를 선언하여 사용한다

```kotlin
var queue: Queue<Int> = LinkedList<Int>()
```

### 210802 이진탐색

Collection의 BinarySearch : 배열이 정렬된 경우만 사용가능, 중복된 값이 있을경우 어떤 인덱스를 리턴할지 모름. 또한 없는값일경우 그값이 들어갈 다음 자리를 마이너스를 붙여서 리턴함 

```kotlin
Collections.binarySearch(정렬된배열, 찾을값)
```

이진 탐색을 직접 구현 할경우

```kotlin
fun binarySearch(arr: IntArray, target: Int): Int {
    var low = 0
    var high = arr.lastIndex
    var mid = 0;

    while (low <= high) {
//1. 배열의 중간에 있는 값을 선택
        mid = (low + high) / 2

        when {
//2. 배열의 중간값이면 바로 찾았으니 리턴
            arr[mid] == target -> return mid
//3. 배열의 중간값 보다 작은경우 좌측으로 탐색
            arr[mid] > target -> high = mid - 1
//4. 배열의 중간값 보다 큰경우 우측으로 탐색
            else -> low = mid + 1
        }
//반복
    }
    return 못찾음
}
```

### 210803 Chunk

Chunked()는 Collection을 주어진 크기로 나눠준다

만약 [ 1, 2, 3, 4 ] 를 chunked(2)로 받으면 [ [1,2] ,[3,4] ] 로 리턴해준다.

또한 람다식을 사용할 수 있다.

```kotlin
val arr = arrayOf(1,2,3,4)
val chunk = arr.chunked(2)

chunk -> [ [1,2] ,[3,4] ] 로 리턴되는것

chunk = arr.chunked(2){it.sum()}

chunk -> [3 , 7] 로 람다식도 가능
```

### 210815 PriorityQueue

우선순위 큐의 경우 java.util의 것을 사용한다

Collections.reverseOrder()을 사용하면 우선순위가 반대로 지정된다

디폴트는 작은것이 맨앞 ex ) 3 0 1 → 0 1 3

reverseorder 사용시 ex) 3 0 1 → 3 1 0  

```kotlin
// 1
val pq = PriorityQueue<Int>()
// 2 
val pq = PriorityQueue<Int>(Collections.reverseOrder())
```

계속해서 읽어들이기는 while문에서 isNullOrEmpty를 조건으로 사용하여 값이 들어오는대로 읽어들일수 있다.

 

```kotlin
var temp = readLine()
while (!temp.isNullOrEmpty()) { 
// 다음 조건을위해 마지막에 다음줄읽기
	temp = readLine() 
}
```